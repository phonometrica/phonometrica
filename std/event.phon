########################################################################################################################
# Copyright (C) 2019 Julien Eychenne <jeychenne@gmail.com>                                                             #
#                                                                                                                      #
# This software is governed by the CeCILL license under French law and abiding by the rules of distribution of free    #
# software. You can use, modify and/or redistribute the software under the terms of the CeCILL license as circulated   #
# by CEA, CNRS and INRIA at the following URL "http://www.cecill.info".                                                #
#                                                                                                                      #
# As a counterpart to the access to the source code and  rights to copy, modify and redistribute granted by the        #
# license, users are provided only with a limited warranty and the software's author, the holder of the economic       #
# rights, and the successive licensors have only limited liability.                                                    #
#                                                                                                                      #
# In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or         #
# developing or reproducing the software by the user in light of its specific status of free software, that may mean   #
# that it is complicated to manipulate, and that also therefore means that it is reserved for developers and           #
# experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the    #
# software's suitability as regards their requirements in conditions enabling the security of their systems and/or     #
# data to be ensured and, more generally, to use and operate it in the same conditions as regards security.            #
#                                                                                                                      #
#                                                                                                                      #
# The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you    #
# accept its terms.                                                                                                    #
#                                                                                                                      #
# Created: 23/02/2019                                                                                                  #
#                                                                                                                      #
# purpose: a simple event/callback (a.k.a signal/slot) mechanism. Events are unique identifiers generated with         #
# event.create(). An event can be connected/disconnected to/from a number of callbacks. Callbacks can be pure          #
# Phonometrica functions or C++ functions exposed to the scripting engine. Phonometrica's callbacks are allowed to     #
# return a value. Values returned by all the callbacks connected to an event are collected into a list, which is       #
# returned by emit().                                                                                                  #
#                                                                                                                      #
########################################################################################################################

# Table mapping an event ID (obtained from ) to a list of callbacks
var bindings = {}
var slot_id = 0

# Event handling module
event = {}

# Create a new event id (this function will be added by the C++ code)
event.create = function() 
    return "__evt_" + String(slot_id++)
end

# connect an event to a slot
event.connect = function(id, slot)
    var callbacks = bindings.get(id, null)

    if callbacks then
        # Check whether the event is already there
        foreach var s in callbacks do
            if slot == s then
                return
            end
        end

        callbacks.append(slot)
    else
        bindings[id] = [ slot ]
    end
end

# disconnect an event from a slot
event.disconnect = function(id, slot)
    var callbacks = bindings.get(id, null)

    if callbacks then
        for var i = callbacks.length downto 1 do
            if callbacks[i] == slot then
                callbacks.remove_at(i)
                return
            end
        end
    end
end

# emit an event, with a number of arguments which will be passed to each slot the event is connected to.
event.emit = function(id, arg)
    var callbacks = bindings.get(id, null)

    if callbacks then
		var result = []

        foreach var callback in callbacks do
            var r = callback(arg)
			result.append(r)
        end

		return result
    end
end

# Define standard events
event.annotation_loaded = "__evt_annotation_loaded"
event.sound_loaded = "__evt_sound_loaded"
event.script_loaded = "__evt_script_loaded"
event.document_loaded = "__evt_document_loaded"
event.dataset_loaded = "__evt_dataset_loaded"
event.project_loaded = "__evt_project_loaded"


!*
function test(arg)
    print("Ã§a marche !", arg)
end
var EVT = event.create()
event.connect(EVT, test)
event.emit(EVT, "XXX")
event.disconnect(EVT, test)
event.emit(EVT, "!!!") # does nothing
*!
